// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol";
import "@aave/core-v3/contracts/interfaces/IPool.sol";
import "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol";
import { ISwapRouter } from "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IAerodromeRouter } from "../interfaces/IAerodromeRouter.sol";

abstract contract ArbitrageBot is IFlashLoanSimpleReceiver {
    IPoolAddressesProvider public provider;
    ISwapRouter public uniswapRouter;
    IAerodromeRouter public aerodromeRouter;
    address public usdc;
    address public weth;
    uint24 public poolFee = 3000; // Default Uniswap V3 pool fee of 0.3%

    constructor(
        address _provider, 
        address _uniswapRouter, 
        address _aerodromeRouter,
        address _usdc, 
        address _weth
    ) {
        provider = IPoolAddressesProvider(_provider);
        uniswapRouter = ISwapRouter(_uniswapRouter);
        aerodromeRouter = IAerodromeRouter(_aerodromeRouter);
        usdc = _usdc;
        weth = _weth;
    }

    // Initiates the flash loan
    function executeArbitrage() external {
        IPool lendingPool = IPool(provider.getPool());

        // Request a flash loan of 5000 USDC
        uint256 loanAmount = 5000 * 10**6; // 5000 USDC in 6 decimals

        // Call the flash loan from Aave V3
        lendingPool.flashLoanSimple(
            address(this), // Address of the contract receiving the loan
            usdc,          // Token to borrow
            loanAmount,    // Amount to borrow
            "",            // No additional params needed for this example
            0              // Referral code
        );
    }

    // Function called after receiving the flash loaned amount
    function executeOperation(
        address asset, 
        uint256 amount, 
        uint256 premium
        // address initiator, 
        // bytes calldata params
    ) external  returns (bool) {
        // Check arbitrage opportunity between Uniswap and Aerodrome
        uint256 usdcBalance = IERC20(asset).balanceOf(address(this));

        uint256 amountOutUniswap = getAmountOutUniSwap(uniswapRouter, usdc, weth, usdcBalance);
        uint256 amountOutAerodrome = getAmountOutAerodrome(aerodromeRouter, usdc, weth, usdcBalance);

        if (amountOutUniswap > amountOutAerodrome) {
            // Perform arbitrage on Uniswap
            swap(uniswapRouter, usdc, weth, usdcBalance);
            uint256 wethBalance = IERC20(weth).balanceOf(address(this));
            swap(uniswapRouter, weth, usdc, wethBalance);
        } else {
            // Perform arbitrage on Aerodrome
            swapAerodrome(aerodromeRouter, usdc, weth, usdcBalance);
            uint256 wethBalance = IERC20(weth).balanceOf(address(this));
            swapAerodrome(aerodromeRouter, weth, usdc, wethBalance);
        }

        // Repay flash loan with premium (loan + fee)
        uint256 totalDebt = amount + premium;
        IERC20(usdc).approve(address(provider.getPool()), totalDebt);

        return true;
    }

    // Helper function to get amountOut from the swap
    function getAmountOutUniSwap(
        ISwapRouter router, 
        address tokenIn, 
        address tokenOut, 
        uint256 amountIn
    ) internal returns (uint256) {
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            fee: poolFee,
            recipient: address(this),
            deadline: block.timestamp + 15,  // 15 seconds from now
            amountIn: amountIn,
            amountOutMinimum: 0,
            sqrtPriceLimitX96: 0
        });

        uint256 amountOut = router.exactInputSingle(params);
        return amountOut;
    }

     function getAmountOutAerodrome(
        IAerodromeRouter router, 
        address tokenIn, 
        address tokenOut, 
        uint256 amountIn
    ) internal returns (uint256) {
     
    }

    // Helper function to swap tokens using Uniswap or Aerodrome
    function swap(
        ISwapRouter router, 
        address tokenIn, 
        address tokenOut, 
        uint256 amountIn
    ) internal {
        IERC20(tokenIn).approve(address(router), amountIn);

        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            fee: poolFee,
            recipient: address(this),
            deadline: block.timestamp + 15,  // 15 seconds from now
            amountIn: amountIn,
            amountOutMinimum: 0,             // Accept any amount of tokenOut
            sqrtPriceLimitX96: 0
        });

        // Execute the swap
        router.exactInputSingle(params);
        
    }  


    function swapAerodrome(
        IAerodromeRouter router, 
        address tokenIn, 
        address tokenOut, 
        uint256 amountIn
    ) internal {
        IERC20(tokenIn).approve(address(router), amountIn);

    }
}
